1.数据结构和算法分析：
这道题目是采用散列（hash table）来做的，开了一个大约是名字个数四倍的散列表，以确保连在一起的名字不会太多。
每次读入，使用每一位*11 mod 40009的方法编码。同时存储一个名字库，每次插入了一个新名字，就把散列中对应的位置链接到名字库中方便比较。
采用开放式存储，每次已经存放了东西就往后面走一格。
记录了姓名的长度，在比较的时候如果长度不一样就可以直接不比较。事后证明这一步是不必要的。
本题对我来说比较坑的地方是字符串的读入！因为没有使用过字符数组，所以我一开始是一位一位读入的，结果虽然在自己的电脑上没问题，但可能由于
编码的一些问题，在oj上一直runtime error 11。后来改成整体读入，竟然立刻过了。这中间调了四五个小时，最后发现是这个问题，看来细节非常重要，
而且基础要打牢啊！

2.时间复杂度：
读入：O(n*length)，length是比较小的常数，所以是O(n)的。编码也是常数时间。之后的装填过程要视情况而定，但重复不会太多，基本可以控制在常数时间。
如果把散列开大一点，重复次数可以控制的更小！（实测，如果开大一倍，总时间大概降为0.7	~0.8倍）
整体是O(n)，常数较大，至少高出一个数量级。（实际可能高出了两个数量级）

3.空间复杂度：
对散列来说，是M的大小（M是事先定好的）。
对姓名库来说，是O(n)的字符数组，考虑到每个数组存放了至多8位有效字符，转化成整数大概是2n，又除了姓名库还存储了配套的长度和出现次数，
最后整体空间复杂度是O(M+n)的。