这道题目采用深度优先搜索（拓扑排序）的方法。
开一个数组，存储每一个节点作为起点，往后可能获得的最大路径。
在深搜的过程中逐步构造出这个数组，每次深搜的起点都是入度为0的点（要利润尽量大，那么路径肯定越长越好，所以最大路径的起点一定入度为0），这样就可以把所有路径都走遍。
采用列表存储每个节点的所有后继（邻居），搜索时依次对每个邻居进行搜索即可。
由于每条路径只会走一次，所以时间复杂度是O(m)。（实际上考虑初始化、读入等，总的时间复杂度是o(m+n)，但n比m小很多）
空间复杂度，需要开若干个n维向量，而且每一条边都要存储，所以是O(n+m)的。