1.思路：这道题采用KMP算法对字符串进行匹配。每次都从头开始逐一比对，找到相同的为止。
       为了实现循环的字符串，把么一个字符串复制一遍首尾相接，这样，假如一个字符串的0..n位和一个被复制过的字符串中间一段匹配了，就说明这是两个相同的字符串。
       优化方案：跳过无意义的比对：（1）假如这个字符串不是历史上第一次出现，直接跳过。
       （2）假如这个字符串的字母都和要比对的字符串不一样，那么直接跳过。（2）的实现相当于做一个散列的映射，但是因为字符串是可以循环的，所以安全起见必须把每一位同等对待，比如我的函数是：把每一位加起来。这样，如果两个字符串的这个函数值都不一样，直接跳过。
2.时间复杂度：视情况而定，对于最坏情况，依然是O(m*m*n)的，但对一般情况（要求出现的字母不能太少，否则很容易散列函数值相同），可以省去大量的比对次数。
            即，对于一般情况，只有O(m*(m+n))的复杂度，即仍然有m次搜查，但只发生常数次字符串比对。m<<n时，也可以写成是O(m*n)。但是这个常数是不确定的，其大小取决于字母不完全相同的字符串个数以及不重复的字符串个数。
3.空间复杂度：存放了字符串的数组，大小为m*n（字符个数）。另外有几个存放中间量的整形字符串，m，忽略不计。
			所以空间复杂度O(m*n)。