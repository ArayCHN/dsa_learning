本题思路：
首先利用中序遍历和先序遍历把这棵树构建出来，再输出它的后序遍历。
构建方法：分治法，首先找到这棵树的根节点。在中序遍历中找到根节点的位置，此时，中序遍历左侧的都是左子树，中序遍历右侧的都是右子树。此时，再分别去重构左子树和右子树。当分到只剩下自己一个节点，就返回自己。构建的时候，只需要记录每个节点的左右孩子即可。
在输出的时候，同样用分治的方法，先输出左子树，再输出右子树，最后输出自己。
在递归过程中，在先序遍历和中序遍历序列中，每个节点（元素）只会被访问一次，（或者说算上访问完子树后再返回上来，最多也只有两次），因此重构的时间复杂度是O(n)。
输出后序遍历，每个节点也只访问一次，也是O(n)的。
所以整体的时间复杂度是O(n)的。
存储输入的序列和重构的树需要的空间是O(n)的。
递归用到的系统栈空间也是O(n)，且只有在这棵树退化成一条链的时候是O(n)，如果是比较好的，接近完全二叉树的树，则只要O(log(n))
因此空间复杂度是O(n)。